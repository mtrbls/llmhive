import Big, { BigSource } from 'big.js';
import type * as Proto from '../grpc-api/v2/concordium/protocol-level-tokens.js';
/**
 * Protocol level token (PLT) amount JSON representation.
 *
 * Please note that `bigint` is used to represent the token amount, which is needed for precise representation of large numbers.
 * As such, extra steps must be taken to serialize and deserialize the token amount.
 */
export type JSON = {
    /** The integer representation of the token amount as a string. */
    value: string;
    /** The decimals of the token amount, defining the precision at which amounts of the token can be specified. */
    decimals: number;
};
/**
 * Enum representing the types of errors that can occur with token amounts.
 */
export declare enum ErrorType {
    /** Error type indicating the token amount exceeds the maximum allowed value. */
    EXCEEDS_MAX_VALUE = "EXCEEDS_MAX_VALUE",
    /** Error type indicating the token amount is negative. */
    NEGATIVE = "NEGATIVE",
    /** Error type indicating the token amount has more decimals than allowed. */
    EXCEEDS_MAX_DECIMALS = "EXCEEDS_MAX_DECIMALS",
    /** Error type indicating the token decimals were specified as a fractional number. */
    FRACTIONAL_DECIMALS = "FRACTIONAL_DECIMALS"
}
/**
 * Custom error to represent issues with token amounts.
 */
export declare class Err extends Error {
    /** The {@linkcode ErrorType} of the error. Can be used as to distinguish different types of errors. */
    readonly type: ErrorType;
    private constructor();
    /**
     * Creates a TokenAmount.Err indicating that the token amount exceeds the maximum allowed value.
     */
    static exceedsMaxValue(): Err;
    /**
     * Creates a TokenAmount.Err indicating that the token amount/decimals is negative.
     */
    static negative(): Err;
    /**
     * Creates a TokenAmount.Err indicating that the token amount has more decimals than allowed.
     */
    static exceedsMaxDecimals(): Err;
    /** Creates a TokenAmount.Err indicating the token decimals were specified as a fractional number. */
    static fractionalDecimals(): Err;
}
/**
 * Protocol level token (PLT) amount representation.
 */
declare class TokenAmount {
    #private;
    /** The unsigned integer representation of the token amount. */
    readonly value: bigint;
    /** The decimals of the token amount, defining the precision at which amounts of the token can be specified. */
    readonly decimals: number;
    /**
     * Constructs a new TokenAmount instance.
     * Validates that the value is within the allowed range and is non-negative.
     *
     * @throws {Err} If the value/decimals exceeds the maximum allowed or is negative.
     */
    constructor(
    /** The unsigned integer representation of the token amount. */
    value: bigint, 
    /** The decimals of the token amount, defining the precision at which amounts of the token can be specified. */
    decimals: number);
    /**
     * Get a string representation of the token amount.
     * @returns {string} The string representation.
     */
    toString(): string;
    /**
     * Get a JSON-serializable representation of the token amount. This is called implicitly when serialized with JSON.stringify.
     * @returns {HexString} The JSON representation.
     */
    toJSON(): JSON;
}
/**
 * Protocol level token (PLT) amount representation.
 */
export type Type = TokenAmount;
/**
 * Type predicate for {@linkcode Type}
 *
 * @param value value to check.
 * @returns whether `value` is of type {@linkcode Type}
 */
export declare function instanceOf(value: unknown): value is TokenAmount;
/**
 * Creates a TokenAmount from a number, string, {@linkcode Big}, or bigint.
 *
 * @param amount The amount of tokens as a number, string, big or bigint.
 * @returns {TokenAmount} The token amount.
 *
 * @throws {Err} If the value exceeds the maximum allowed or is negative.
 */
export declare function fromDecimal(amount: BigSource | bigint, decimals: number): TokenAmount;
/**
 * Convert a token amount into a decimal value represented as a {@linkcode Big}
 *
 * @param {TokenAmount} amount
 * @returns {Big} The token amount as a {@linkcode Big}.
 */
export declare function toDecimal(amount: TokenAmount): Big;
/**
 * Converts {@linkcode JSON} to a token amount.
 *
 * @param {JSON} json The JSON representation of the token amount.
 * @returns {TokenAmount} The token amount.
 * @throws {Err} If the value/decimals exceeds the maximum allowed or is negative.
 */
export declare function fromJSON(json: JSON): TokenAmount;
/**
 * Creates a token amount from its integer representation and a number of decimals.
 *
 * @param {bigint} value The integer representation of the token amount.
 * @param {number} decimals The decimals of the token amount, defining the precision at which amounts of the token can be specified.
 *
 * @returns {TokenAmount} The token amount.
 * @throws {Err} If the value/decimals exceeds the maximum allowed or is negative.
 */
export declare function create(value: bigint, decimals: number): TokenAmount;
/**
 * Creates a token amount with a value of zero.
 *
 * @param {number} decimals The decimals of the token amount, defining the precision at which amounts of the token can be specified.
 * @returns {TokenAmount} The token amount.
 */
export declare function zero(decimals: number): TokenAmount;
/**
 * Convert token amount from its protobuf encoding.
 * @param {Proto.TokenAmount} amount
 * @returns {Type} The token amount.
 * @throws {Err} If the value/decimals exceeds the maximum allowed or is negative.
 */
export declare function fromProto(amount: Proto.TokenAmount): Type;
/**
 * Convert token amount into its protobuf encoding.
 * @param {TokenAmount} amount
 * @returns {Proto.TokenAmount} The protobuf encoding.
 */
export declare function toProto(amount: Type): Proto.TokenAmount;
/**
 * Check if two token amounts are the same. This tests for numeric equlity, not equality of object values.
 *
 * @example
 * const a = TokenAmount.create(1, 2);
 * const b = TokenAmount.create(100, 4);
 * console.log(TokenAmount.equals(a, b)); // true
 *
 * @param {TokenAmount} left
 * @param {TokenAmount} right
 * @returns {boolean} True if they are equal.
 */
export declare function equals(left: TokenAmount, right: TokenAmount): boolean;
/**
 * Converts a TokenAmount to its CBOR (Concise Binary Object Representation) `decfrac` encoding.
 *
 * @param {TokenAmount} value - The token amount to convert to CBOR format.
 * @returns {Uint8Array} The CBOR encoded representation of the token amount.
 */
export declare function toCBOR(value: TokenAmount): Uint8Array;
/**
 * Function to parse a CBOR-decoded `decfrac` value into a TokenAmount instance.
 * This handles the internal conversion from the CBOR representation to our TokenAmount type.
 *
 * @param {unknown} decoded - The decoded CBOR value
 * @returns {TokenAmount} The parsed TokenAmount instance
 * @throws {Error} If the value is not in the expected `decfrac` format
 */
export declare function fromCBORValue(decoded: unknown): TokenAmount;
/**
 * Decodes a CBOR `decfrac` encoding into a TokenAmount instance.
 *
 * @param {Uint8Array} bytes - The CBOR `decfrac` encoding.
 * @throws {Error} - If the input is not a valid CBOR encoding of a token amount.
 * @returns {TokenAmount} The decoded TokenAmount instance.
 */
export declare function fromCBOR(bytes: Uint8Array): TokenAmount;
/**
 * Registers a CBOR encoder for the TokenAmount type with the `cbor2` library.
 * This allows TokenAmount instances to be automatically encoded when used with
 * the `cbor2` library's encode function.
 *
 * @returns {void}
 * @example
 * // Register the encoder
 * registerCBOREncoder();
 * // Now TokenAmount instances can be encoded directly
 * const encoded = encode(myTokenAmount);
 */
export declare function registerCBOREncoder(): void;
/**
 * Registers a CBOR decoder for the decimal fraction (tag 4) format with the `cbor2` library.
 * This enables automatic decoding of CBOR data containing token amounts
 * when using the `cbor2` library's decode function.
 *
 * @returns {() => void} A cleanup function that, when called, will restore the previous
 * decoder (if any) that was registered for the decimal fraction format. This is useful
 * when used in an existing `cbor2` use-case.
 *
 * @example
 * // Register the decoder
 * const cleanup = registerCBORDecoder();
 * // Use the decoder
 * const tokenAmount = decode(cborBytes); // Returns TokenAmount if format matches
 * // Later, unregister the decoder
 * cleanup();
 */
export declare function registerCBORDecoder(): () => void;
export {};
