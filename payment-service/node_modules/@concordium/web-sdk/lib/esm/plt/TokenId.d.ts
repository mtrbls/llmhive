import type * as Proto from '../grpc-api/v2/concordium/protocol-level-tokens.js';
/**
 * Protocol level token (PLT) ID JSON representation.
 */
export type JSON = string;
/**
 * Enum representing the types of errors that can occur with token IDs.
 */
export declare enum ErrorType {
    /** Error type indicating the length exceeds the max allowed. */
    EXCEEDS_MAX_LENGTH = "EXCEEDS_MAX_LENGTH",
    /** Error type indicating the length is below the min allowed. */
    BELOW_MIN_LENGTH = "BELOW_MIN_LENGTH",
    /** Error type indicating the token ID contains invalid characters. */
    INVALID_CHARACTERS = "INVALID_CHARACTERS"
}
/**
 * Custom error to represent issues with token IDs.
 */
export declare class Err extends Error {
    /** The {@linkcode ErrorType} of the error. Can be used as to distinguish different types of errors. */
    readonly type: ErrorType;
    private constructor();
    /**
     * Creates a TokenId.Err indicating the length exceeds the max allowed.
     */
    static exceedsMaxLength(): Err;
    /**
     * Creates a TokenId.Err indicating the length is below the min allowed.
     */
    static belowMinLength(): Err;
    /**
     * Creates a TokenId.Err indicating the token ID contains invalid characters.
     */
    static invalidCharacters(): Err;
}
/**
 * Protocol level token (PLT) ID.
 */
declare class TokenId {
    #private;
    /** The inner value, as provided */
    readonly value: string;
    /**
     * Constructs a new TokenId instance.
     * Validates that the value matches the allowed constraints.
     *
     * @throws {Err} If the value is not valid according to the constraints.
     */
    constructor(
    /** The inner value, as provided */
    value: string);
    /**
     * Get a string representation of the token ID.
     * @returns {string} The string representation.
     */
    toString(): string;
    /**
     * Get a JSON-serializable representation of the token ID. This is called implicitly when serialized with JSON.stringify.
     * @returns {HexString} The JSON representation.
     */
    toJSON(): JSON;
}
/**
 * Protocol level token (PLT) ID.
 */
export type Type = TokenId;
/**
 * Create a protocol level token ID from a string value.
 *
 * @param {string} value - The string to create the token ID from.
 * @returns {TokenId} A new token ID instance.
 * @throws {Err} If the value is longer than 255 utf-8 encoded bytes or contains invalid UTF-8.
 */
export declare function fromString(value: string): TokenId;
/**
 * Type predicate for {@linkcode Type}
 *
 * @param value value to check.
 * @returns whether `value` is of type {@linkcode Type}
 */
export declare function instanceOf(value: unknown): value is TokenId;
/**
 * Converts {@linkcode JSON} to a token amount.
 *
 * @param {string} json The JSON representation of the token ID.
 * @returns {TokenId} The token ID.
 * @throws {Err} If the value is longer than 255 utf-8 encoded bytes or contains invalid UTF-8.
 */
export declare function fromJSON(json: JSON): TokenId;
/**
 * Convert token ID from its protobuf encoding.
 * @param {Proto.TokenId} tokenId the token ID
 * @returns {TokenId} The token ID.
 * @throws {Err} If the value is longer than 255 utf-8 encoded bytes or contains invalid UTF-8.
 */
export declare function fromProto(tokenId: Proto.TokenId): TokenId;
/**
 * Convert token ID into its protobuf encoding.
 * @param {TokenId} tokenId The token ID.
 * @returns {Proto.TokenId} The protobuf encoding.
 */
export declare function toProto(tokenId: Type): Proto.TokenId;
/**
 * Encode a TokenId to UTF-8 bytes. This is the serialization format used for token IDs in transactions.
 *
 * @param {TokenId} tokenId - The TokenId to encode.
 * @returns {Uint8Array} The UTF-8 byte representation of the TokenId.
 */
export declare function toBytes(tokenId: TokenId): Uint8Array;
/**
 * Decode UTF-8 bytes to a TokenId. This can be used to deserialize token IDs in transactions.
 *
 * @param {Uint8Array} bytes - The UTF-8 byte array to decode.
 * @returns {TokenId} The decoded TokenId.
 * @throws {Err} If the decoded string is longer than 255 utf-8 encoded bytes or contains invalid UTF-8.
 */
export declare function fromBytes(bytes: ArrayBuffer): TokenId;
/**
 * Check if two token IDs are the same.
 * @param {TokenId} left
 * @param {TokenId} right
 * @returns {boolean} True if they are equal.
 */
export declare function equals(left: TokenId, right: TokenId): boolean;
export {};
