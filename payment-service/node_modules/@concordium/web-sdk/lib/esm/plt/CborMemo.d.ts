import * as Proto from '../grpc-api/v2/concordium/kernel.js';
import type { HexString } from '../types.js';
/**
 * The JSON representation of a {@linkcode Type} cbor memo
 */
export type JSON = HexString;
/**
 * Representation of a Memo, which enforces that it:
 * - Is a valid byte array with a maximum length of 256 bytes.
 */
declare class CborMemo {
    #private;
    readonly content: Uint8Array;
    constructor(content: Uint8Array);
    /**
     * Get a string representation of the memo.
     *
     * @returns {string} The string representation.
     */
    toString(): string;
    /**
     * Get a JSON-serializable representation of the memo.
     * @returns {JSON} The JSON-serializable representation.
     */
    toJSON(): JSON;
}
/**
 * Representation of a Memo, which enforces that it:
 * - Is a valid byte array with a maximum length of 256 bytes.
 */
export type Type = CborMemo;
/**
 * Type predicate for {@linkcode Type}
 *
 * @param value value to check.
 * @returns whether `value` is of type {@linkcode Type}
 */
export declare function instanceOf(value: unknown): value is CborMemo;
/**
 * Converts a string into a CborMemo object.
 *
 * @param value - The string to be encoded.
 * @returns A new CborMemo object containing the encoded string.
 */
export declare function fromString(value: string): CborMemo;
/**
 * Converts any value to a CborMemo instance.
 *
 * @param value - The value to be encoded and wrapped in a CborMemo.
 * @returns A new CborMemo instance containing the encoded value.
 */
export declare function fromAny(value: unknown): CborMemo;
/**
 * Convert CBOR memo from its protobuf encoding.
 * @param {Proto.Memo} memo The protobuf encoding.
 * @returns {CborMemo}
 */
export declare function fromProto(memo: Proto.Memo): CborMemo;
/**
 * Convert CBOR memo into its protobuf encoding.
 * @param {CborMemo} memo module event.
 * @returns {Proto.Memo}
 */
export declare function toProto(memo: CborMemo): Proto.Memo;
/**
 * Parses a CBOR-encoded memo and returns the decoded value.
 *
 * @param {CborMemo} value - The CBOR memo to parse.
 * @returns {unknown} The decoded value.
 */
export declare function parse(value: CborMemo): unknown;
/**
 * Converts a Memo to its CBOR (Concise Binary Object Representation) encoding.
 * This encodes the memo as a CBOR tagged value with tag 24.
 *
 * @param {CborMemo} value - The memo to convert to CBOR format.
 * @returns {Uint8Array} The CBOR encoded representation of the memo.
 */
export declare function toCBOR(value: CborMemo): Uint8Array;
/**
 * Decodes a CBOR-encoded memo into a CborMemo instance.
 *
 * @param {Uint8Array} bytes - The CBOR encoded representation of a memo.

/**
 * Decodes a CBOR-encoded memo into a CborMemo instance.
 *
 * @param {Uint8Array} bytes - The CBOR encoded representation of a memo.
 * @returns {CborMemo} The decoded CborMemo instance.
 */
export declare function fromCBOR(bytes: Uint8Array): CborMemo;
/**
 * Registers a CBOR encoder for the Memo type with the `cbor2` library.
 * This allows CborMemo instances to be automatically encoded when used with
 * the `cbor2` library's encode function.
 *
 * @returns {void}
 * @example
 * // Register the encoder
 * registerCBOREncoder();
 * // Now CborMemo instances can be encoded directly
 * const encoded = encode(memo);
 */
export declare function registerCBOREncoder(): void;
/**
 * Registers a CBOR decoder for tag 24 (encoded-cbor-data-item) with the `cbor2` library.
 * This enables automatic decoding of CBOR data containing a Memo
 * when using the `cbor2` library's decode function.
 *
 * @returns {() => void} A cleanup function that, when called, will restore the previous
 * decoder (if any) that was registered for the tagged-address format. This is useful
 * when used in an existing `cbor2` use-case.
 *
 * @example
 * // Register the decoder
 * const cleanup = registerCBORDecoder();
 * // Use the decoder
 * const memo = decode(cborBytes); // Returns Memo if format matches
 * // Later, unregister the decoder
 * cleanup();
 */
export declare function registerCBORDecoder(): () => void;
export {};
