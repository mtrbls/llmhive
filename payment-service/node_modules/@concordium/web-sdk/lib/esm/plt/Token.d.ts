import { ConcordiumGRPCClient } from '../grpc/GRPCClient.js';
import { AccountAddress, AccountInfo, TokenUpdatePayload, TransactionExpiry, TransactionHash } from '../pub/types.js';
import { AccountSigner } from '../signHelpers.js';
import { SequenceNumber } from '../types/index.js';
import { TokenAmount, TokenId, TokenInfo, TokenModuleReference, TokenModuleState, TokenOperation, TokenTransfer } from './index.js';
/**
 * Enum representing the types of errors that can occur when interacting with PLT instances through the client.
 */
export declare enum TokenErrorCode {
    /** Error type indicating the token ID does not match the module version expected by the client. */
    INCORRECT_MODULE_VERSION = "INCORRECT_MODULE_VERSION",
    /** Error type indicating the supplied token amount is not compatible with the token. */
    INVALID_TOKEN_AMOUNT = "INVALID_TOKEN_AMOUNT",
    /** Error representing an attempt transfer funds to an account which is either not on the token allow list,
     * or is on the token deny list.
     */
    NOT_ALLOWED = "NOT_ALLOWED",
    /** Error representing an attempt to transfer tokens from an account that does not have enough tokens to cover the
     * amount. */
    INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS",
    /** Error type Error indicating that supply change operation is prohibited while the token is in the paused state.
     */
    PAUSED = "PAUSED",
    /** Error that indicates that the token does not support minting. */
    NOT_MINTABLE = "NOT_MINTABLE",
    /** Error that indicates that the token does not support burning. */
    NOT_BURNABLE = "NOT_BURNABLE",
    /** Error that indicates that allow list is not available for this token. */
    NO_ALLOW_LIST = "NO_ALLOW_LIST",
    /** Error that indicates that deny list is not available for this token. */
    NO_DENY_LIST = "NO_DENY_LIST",
    /** Error that indicates that an account has insufficient amount of token to burn. */
    INSUFFICIENT_SUPPLY = "INSUFFICIENT_SUPPLY"
}
/**
 * Error thrown while interacting with PLT instances through the client.
 */
export declare abstract class TokenError extends Error {
    abstract readonly code: TokenErrorCode;
    private _name;
    /**
     * Constructs a new TokenError.
     * @param {string} message - The error message.
     */
    constructor(message: string);
    /**
     * Gets the name of the error, including its code.
     * @returns {string} The name of the error.
     */
    get name(): string;
}
/** Error type indicating the token ID does not match the module version expected by the client. */
export declare class ModuleVersionMismatchError extends TokenError {
    readonly expectedRef: TokenModuleReference.Type;
    readonly foundRef: TokenModuleReference.Type;
    readonly code = TokenErrorCode.INCORRECT_MODULE_VERSION;
    /**
     * Constructs a new ModuleVersionMismatchError.
     * @param {TokenModuleReference.Type} expectedRef - The expected module reference.
     * @param {TokenModuleReference.Type} foundRef - The found module reference.
     */
    constructor(expectedRef: TokenModuleReference.Type, foundRef: TokenModuleReference.Type);
}
/** Error type indicating the supplied token amount is not compatible with the token. */
export declare class InvalidTokenAmountError extends TokenError {
    readonly tokenDecimals: number;
    readonly amount: TokenAmount.Type;
    readonly code = TokenErrorCode.INVALID_TOKEN_AMOUNT;
    /**
     * Constructs a new InvalidTokenAmountError.
     * @param {number} tokenDecimals - The number of decimals the token supports.
     * @param {TokenAmount.Type} amount - The token amount that is invalid.
     */
    constructor(tokenDecimals: number, amount: TokenAmount.Type);
}
/**
 * Error type indicating an attempt transfer funds to/from an account which is either not on the token allow list, or is on the token deny list
 */
export declare class NotAllowedError extends TokenError {
    readonly receiver: AccountAddress.Type;
    readonly code = TokenErrorCode.NOT_ALLOWED;
    /**
     * Constructs a new NotAllowedError.
     * @param {AccountAddress.Type} receiver - The account address of the receiver.
     */
    constructor(receiver: AccountAddress.Type);
}
/**
 * Error type indicating insufficient funds for a transaction.
 */
export declare class InsufficientFundsError extends TokenError {
    readonly sender: AccountAddress.Type;
    readonly requiredAmount: TokenAmount.Type;
    readonly code = TokenErrorCode.INSUFFICIENT_FUNDS;
    /**
     * Constructs a new InsufficientFundsError.
     *
     * @param {AccountAddress.Type} sender - The account address of the sender.
     * @param {TokenAmount.Type} requiredAmount - The amount of tokens required for the transaction.
     */
    constructor(sender: AccountAddress.Type, requiredAmount: TokenAmount.Type);
}
/**
 * Error type indicating that the token is paused.
 */
export declare class PausedError extends TokenError {
    readonly tokenId: TokenId.Type;
    readonly code = TokenErrorCode.PAUSED;
    /**
     * Constructs a new PausedError.
     *
     * @param {TokenId.Type} tokenId - The ID of the token.
     */
    constructor(tokenId: TokenId.Type);
}
/**
 * Error type indicating that the token is not mintable.
 */
export declare class NotMintableError extends TokenError {
    readonly tokenId: TokenId.Type;
    readonly code = TokenErrorCode.NOT_MINTABLE;
    /**
     * Constructs a new NotMintableError.
     *
     * @param {TokenId.Type} tokenId - The ID of the token.
     */
    constructor(tokenId: TokenId.Type);
}
/**
 * Error type indicating that the token is not burnable.
 */
export declare class NotBurnableError extends TokenError {
    readonly tokenId: TokenId.Type;
    readonly code = TokenErrorCode.NOT_BURNABLE;
    /**
     * Constructs a new NotBurnableError.
     *
     * @param {TokenId.Type} tokenId - The ID of the token.
     */
    constructor(tokenId: TokenId.Type);
}
/**
 * Error type indicating that the token has no allow list.
 */
export declare class NoAllowListError extends TokenError {
    readonly tokenId: TokenId.Type;
    readonly code = TokenErrorCode.NO_ALLOW_LIST;
    /**
     * Constructs a new NoAllowListError.
     *
     * @param {TokenId.Type} tokenId - The ID of the token.
     */
    constructor(tokenId: TokenId.Type);
}
/**
 * Error type indicating that the token has no deny list.
 */
export declare class NoDenyListError extends TokenError {
    readonly tokenId: TokenId.Type;
    readonly code = TokenErrorCode.NO_DENY_LIST;
    /**
     * Constructs a new NoDenyListError.
     *
     * @param {TokenId.Type} tokenId - The ID of the token.
     */
    constructor(tokenId: TokenId.Type);
}
/**
 * Error type indicating insufficient supply for the burning.
 */
export declare class InsufficientSupplyError extends TokenError {
    readonly sender: AccountAddress.Type;
    readonly requiredAmount: TokenAmount.Type;
    readonly code = TokenErrorCode.INSUFFICIENT_SUPPLY;
    /**
     * Constructs a new InsufficientSupplyError.
     *
     * @param {AccountAddress.Type} sender - The account address of the sender.
     * @param {TokenAmount.Type} requiredAmount - The amount of tokens required for the burn.
     */
    constructor(sender: AccountAddress.Type, requiredAmount: TokenAmount.Type);
}
/**
 * Class representing a token.
 */
declare class Token {
    readonly grpc: ConcordiumGRPCClient;
    /** The parsed module state of the token. */
    private _info;
    private _moduleState;
    /**
     * Constructs a new Token.
     * @param {ConcordiumGRPCClient} grpc - The gRPC client for interacting with the Concordium network.
     * @param {TokenInfo} info - Information about the token.
     */
    constructor(grpc: ConcordiumGRPCClient, info: TokenInfo);
    get info(): TokenInfo;
    get moduleState(): TokenModuleState;
    /**
     * Mutates this instance with fresh info and keeps fields in sync.
     * Returns `this` for ergonomic chaining / capturing a reference if desired.
     */
    update(): Promise<this>;
}
export type Type = Token;
/**
 * Creates a Token instance from a token ID.
 * @param {ConcordiumGRPCClient} grpc - The gRPC client for interacting with the Concordium network.
 * @param {TokenId.Type} tokenId - The ID of the token.
 * @returns {Promise<Token>} A promise that resolves to a Token instance.
 */
export declare function fromId(grpc: ConcordiumGRPCClient, tokenId: TokenId.Type): Promise<Token>;
/**
 * Creates a Token instance from token information.
 * @param {ConcordiumGRPCClient} grpc - The gRPC client for interacting with the Concordium network.
 * @param {TokenInfo} tokenInfo - Information about the token.
 * @returns {Token} A Token instance.
 */
export declare function fromInfo(grpc: ConcordiumGRPCClient, tokenInfo: TokenInfo): Token;
/**
 * Validates if the given token amount is compatible with the token.
 *
 * @param {Token} token - The token to validate against.
 * @param {TokenAmount.Type} amount - The amount to validate.

 * @returns {true} If the amount is valid within the context of the token.
 * @throws {InvalidTokenAmountError} If the token amount is not compatible with the token.
 */
export declare function validateAmount(token: Token, amount: TokenAmount.Type): true;
/**
 * Scales a token amount with fewer decimals to the token's decimal representation.
 *
 * @param {Token} token - The token to scale the amount for.
 * @param {TokenAmount.Type} amount - The amount to scale.
 * @returns {TokenAmount.Type} The scaled token amount.
 * @throws {InvalidTokenAmountError} If the token amount is not compatible with the token.
 */
export declare function scaleAmount(token: Token, amount: TokenAmount.Type): TokenAmount.Type;
/**
 * Initiates a transaction for a given token.
 *
 * This function creates and sends a transaction of type `TokenUpdate` for the specified token.
 *
 * @param {Token} token - The token for which the transaction is being performed.
 * @param {AccountAddress.Type} sender - The account address initiating the transaction.
 * @param {TokenUpdatePayload} payload - The transaction payload.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 *
 * @returns {Promise<TransactionHash.Type>} A promise that resolves to the transaction hash.
 */
export declare function sendRaw(token: Token, sender: AccountAddress.Type, payload: TokenUpdatePayload, signer: AccountSigner, { expiry, nonce }?: TokenUpdateMetadata): Promise<TransactionHash.Type>;
/**
 * The response type for the `balanceOf` function.
 */
export type BalanceOfResponse = TokenAmount.Type | undefined;
/**
 * Retrieves the balance of a token for a given account.
 *
 * @param {Token} token - The token to check the balance of.
 * @param {AccountInfo} accountInfo - The account to check the balance for.
 *
 * @returns {BalanceOfResponse} The balance of the token for the account.
 */
export declare function balanceOf(token: Token, accountInfo: AccountInfo): BalanceOfResponse;
/**
 * Retrieves the balance of a token for a given account.
 *
 * @param {Token} token - The token to check the balance of.
 * @param {AccountAddress.Type} accountAddress - The account to check the balance for.
 *
 * @returns {Promise<BalanceOfResponse>} The balance of the token for the account.
 */
export declare function balanceOf(token: Token, accountAddress: AccountAddress.Type): Promise<BalanceOfResponse>;
/**
 * Validates a token transfer.
 *
 * @param {Token} token - The token to transfer.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {TokenTransfer | TokenTransfer[]} payload - The transfer payload.
 *
 * @returns {Promise<true>} A promise that resolves to true if the transfer is valid.
 * @throws {InvalidTokenAmountError} If any token amount is not compatible with the token.
 * @throws {InsufficientFundsError} If the sender does not have enough tokens.
 * @throws {NotAllowedError} If the sender or receiver is not allowed to send/receive tokens.
 * @throws {PausedError} If the token is paused.
 */
export declare function validateTransfer(token: Token, sender: AccountAddress.Type, payload: TokenTransfer | TokenTransfer[]): Promise<true>;
/**
 * Validates a token mint.
 *
 * @param {Token} token - The token to mint.
 * @param {TokenAmount.Type | TokenAmount.Type[]} amounts - The amounts of tokens to mint.
 *
 * @returns {Promise<true>} A promise that resolves to true if the minting is valid.
 * @throws {InvalidTokenAmountError} If any token amount is not compatible with the token.
 * @throws {PausedError} If the token is paused.
 * @throws {NotMintableError} If the the token if not mintable.
 */
export declare function validateMint(token: Token, amounts: TokenAmount.Type | TokenAmount.Type[]): Promise<true>;
/**
 * Validates a token burn.
 *
 * @param {Token} token - The token to burn.
 * @param {TokenAmount.Type | TokenAmount.Type[]} amounts - The amounts of tokens to burn.
 *
 * @returns {Promise<true>} A promise that resolves to true if the burning is valid.
 * @throws {InvalidTokenAmountError} If any token amount is not compatible with the token.
 * @throws {PausedError} If the token is paused.
 * @throws {NotBurnableError} If the the token if not burnable.
 * @throws {InsufficientSupplyError} If the sender has insufficent amount of tokens for the burn.
 */
export declare function validateBurn(token: Token, amounts: TokenAmount.Type | TokenAmount.Type[], sender: AccountAddress.Type | AccountInfo): Promise<true>;
/**
 * Validates a token allow list update.
 *
 * @param {Token} token - The token that's allow list is to be updated.
 *
 * @returns {Promise<true>} A promise that resolves to true if the token's allow list can be updated.
 * @throws {NoAllowListError} If the token does not have an allow list.
 */
export declare function validateAllowListUpdate(token: Token): Promise<true>;
/**
 * Validates a token deny list update.
 *
 * @param {Token} token - The token that's deny list is to be updated.
 *
 * @returns {Promise<true>} A promise that resolves to true if the token's deny list can be updated.
 * @throws {NoDenyListError} If the token does not have a deny list.
 */
export declare function validateDenyListUpdate(token: Token): Promise<true>;
export type TokenUpdateMetadata = {
    /**
     * The expiry time for the transaction.
     */
    expiry?: TransactionExpiry.Type;
    /**
     * The the sender account "nonce" for to use for the transaction. If not specified, the
     * nonce will be queried from the node used for the transaction.
     */
    nonce?: SequenceNumber.Type;
};
type TransferOtions = {
    /** Whether to automatically scale a token amount to the correct number of decimals as the token */
    autoScale?: boolean;
    /** Whether to validate the operation client side against the latest finalized state (necessary state will be fetched) before submitting it */
    validate?: boolean;
};
export type TransferInput = Omit<TokenTransfer, 'recipient'> & {
    /** The recipient of the transfer. */
    recipient: AccountAddress.Type;
};
/**
 * Transfers tokens from the sender to the specified recipients.
 *
 * @param {Token} token - The token to transfer.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {TransferInput | TransferInput[]} payload - The transfer payload.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 * @param {TransferOtions} [opts={ autoScale: true, validate: false }] - Options for the transfer.
 *
 * @returns {Promise<TransactionHash.Type>} A promise that resolves to the transaction hash.
 * @throws {InvalidTokenAmountError} If `opts.validate` and any token amount is not compatible with the token.
 * @throws {InsufficientFundsError} If `opts.validate` and the sender does not have enough tokens.
 * @throws {NotAllowedError} If `opts.validate` and a sender or receiver is not allowed to send/receive tokens.
 * @throws {PausedError} If `opts.validate` and the token is paused.
 */
export declare function transfer(token: Token, sender: AccountAddress.Type, payload: TransferInput | TransferInput[], signer: AccountSigner, metadata?: TokenUpdateMetadata, { autoScale, validate }?: TransferOtions): Promise<TransactionHash.Type>;
type SupplyUpdateOptions = {
    /** Whether to automatically scale a token amount to the correct number of decimals as the token */
    autoScale?: boolean;
    /** Whether to validate the operation client side against the latest finalized state (necessary state will be fetched) before submitting it */
    validate?: boolean;
};
/**
 * Mints a specified amount of tokens.
 *
 * @param {Token} token - The token to mint.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {TokenAmount.Type | TokenAmount.Type[]} amounts - The amount(s) of tokens to mint.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 * @param {SupplyUpdateOptions} [opts={ autoScale: true, validate: false }] - Options for supply update operations.
 *
 * @returns A promise that resolves to the transaction hash.
 * @throws {InvalidTokenAmountError} If `opts.validate` and the token amount is not compatible with the token.
 * @throws {PausedError} If `opts.validate` and the token is paused.
 * @throws {NotMintableError} If `opts.validate` and the token is not mintable.
 */
export declare function mint(token: Token, sender: AccountAddress.Type, amounts: TokenAmount.Type | TokenAmount.Type[], signer: AccountSigner, metadata?: TokenUpdateMetadata, { autoScale, validate }?: SupplyUpdateOptions): Promise<TransactionHash.Type>;
/**
 * Burns a specified amount of tokens.
 *
 * @param {Token} token - The token to burn.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {TokenAmount.Type | TokenAmount.Type[]} amounts - The amount(s) of tokens to burn.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 * @param {SupplyUpdateOptions} [opts={ autoScale: true, validate: false }] - Options for supply update operations.
 *
 * @returns A promise that resolves to the transaction hash.
 * @throws {InvalidTokenAmountError} If `opts.validate` and the token amount is not compatible with the token.
 * @throws {PausedError} If `opts.validate` and the token is paused.
 * @throws {NotBurnableError} If `opts.validate` and the token is not burnable.
 * @throws {InsufficientSupplyError} If `opts.validate` and the sender has insufficent amount of tokens for the burn.
 */
export declare function burn(token: Token, sender: AccountAddress.Type, amounts: TokenAmount.Type | TokenAmount.Type[], signer: AccountSigner, metadata?: TokenUpdateMetadata, { autoScale, validate }?: SupplyUpdateOptions): Promise<TransactionHash.Type>;
type UpdateListOptions = {
    /** Whether to validate the operation client side against the latest finalized state (necessary state will be fetched) before submitting it */
    validate?: boolean;
};
/**
 * Adds an account to the allow list of a token.
 *
 * @param {Token} token - The token for which to add the list entry.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {AccountAddress.Type | AccountAddress.Type[]} targets - The account address(es) to be added to the list.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 * @param {UpdateListOptions} [opts={ validate: false }] - Options for updating the allow/deny list.
 *
 * @returns A promise that resolves to the transaction hash.
 * @throws {NoAllowListError} If `opts.validate` and the token does not have allow list.
 */
export declare function addAllowList(token: Token, sender: AccountAddress.Type, targets: AccountAddress.Type | AccountAddress.Type[], signer: AccountSigner, metadata?: TokenUpdateMetadata, { validate }?: UpdateListOptions): Promise<TransactionHash.Type>;
/**
 * Removes an account from the allow list of a token.
 *
 * @param {Token} token - The token for which to add the list entry.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {AccountAddress.Type | AccountAddress.Type[]} targets - The account address(es) to be added to the list.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 * @param {UpdateListOptions} [opts={ validate: false }] - Options for updating the allow/deny list.
 *
 * @returns A promise that resolves to the transaction hash.
 * @throws {NoAllowListError} If `opts.validate` and the token does not have allow list.
 */
export declare function removeAllowList(token: Token, sender: AccountAddress.Type, targets: AccountAddress.Type | AccountAddress.Type[], signer: AccountSigner, metadata?: TokenUpdateMetadata, { validate }?: UpdateListOptions): Promise<TransactionHash.Type>;
/**
 * Adds an account to the deny list of a token.
 *
 * @param {Token} token - The token for which to add the list entry.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {AccountAddress.Type | AccountAddress.Type[]} targets - The account address(es) to be added to the list.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 * @param {UpdateListOptions} [opts={ validate: false }] - Options for updating the allow/deny list.
 *
 * @returns A promise that resolves to the transaction hash.
 * @throws {NoDenyListError} If `opts.validate` and the token does not have deny list.
 */
export declare function addDenyList(token: Token, sender: AccountAddress.Type, targets: AccountAddress.Type | AccountAddress.Type[], signer: AccountSigner, metadata?: TokenUpdateMetadata, { validate }?: UpdateListOptions): Promise<TransactionHash.Type>;
/**
 * Removes an account from the deny list of a token.
 *
 * @param {Token} token - The token for which to add the list entry.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {AccountAddress.Type | AccountAddress.Type[]} targets - The account address(es) to be added to the list.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 * @param {UpdateListOptions} [opts={ validate: false }] - Options for updating the allow/deny list.
 *
 * @returns A promise that resolves to the transaction hash.
 * @throws {NoDenyListError} If `opts.validate` and the token does not have deny list.
 */
export declare function removeDenyList(token: Token, sender: AccountAddress.Type, targets: AccountAddress.Type | AccountAddress.Type[], signer: AccountSigner, metadata?: TokenUpdateMetadata, { validate }?: UpdateListOptions): Promise<TransactionHash.Type>;
/**
 * Suspends execution of any operation involving balance changes for the token.
 *
 * @param {Token} token - The token to pause/unpause.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 *
 * @returns A promise that resolves to the transaction hash.
 */
export declare function pause(token: Token, sender: AccountAddress.Type, signer: AccountSigner, metadata?: TokenUpdateMetadata): Promise<TransactionHash.Type>;
/**
 * Resumes execution of any operation involving balance changes for the token.
 *
 * @param {Token} token - The token to pause/unpause.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 *
 * @returns A promise that resolves to the transaction hash.
 */
export declare function unpause(token: Token, sender: AccountAddress.Type, signer: AccountSigner, metadata?: TokenUpdateMetadata): Promise<TransactionHash.Type>;
/**
 * Executes a batch of operations on a token.
 *
 * @param {Token} token - The token on which to perform the operations.
 * @param {AccountAddress.Type} sender - The account address of the sender.
 * @param {TokenOperation[]} operations - An array of governance operations to execute.
 * @param {AccountSigner} signer - The signer responsible for signing the transaction.
 * @param {TokenUpdateMetadata} [metadata={ expiry: TransactionExpiry.futureMinutes(5) }] - The metadata for the token update.
 *
 * @returns A promise that resolves to the transaction hash.
 */
export declare function sendOperations(token: Token, sender: AccountAddress.Type, operations: TokenOperation[], signer: AccountSigner, metadata?: TokenUpdateMetadata): Promise<TransactionHash.Type>;
export {};
