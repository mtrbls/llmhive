import { Cbor, CborAccountAddress, CborMemo, TokenAmount } from './index.js';
/**
 * Enum representing the types of token operations.
 */
export var TokenOperationType;
(function (TokenOperationType) {
    TokenOperationType["Transfer"] = "transfer";
    TokenOperationType["Mint"] = "mint";
    TokenOperationType["Burn"] = "burn";
    TokenOperationType["AddAllowList"] = "addAllowList";
    TokenOperationType["RemoveAllowList"] = "removeAllowList";
    TokenOperationType["AddDenyList"] = "addDenyList";
    TokenOperationType["RemoveDenyList"] = "removeDenyList";
    TokenOperationType["Pause"] = "pause";
    TokenOperationType["Unpause"] = "unpause";
})(TokenOperationType || (TokenOperationType = {}));
/**
 * Creates a payload for token operations.
 * This function encodes the provided token operation(s) into a CBOR format.
 *
 * @param tokenId - The unique identifier of the token for which the operation(s) is being performed.
 * @param operations - A single token operation or an array of token operations.
 *
 * @returns The encoded token governance payload.
 */
export function createTokenUpdatePayload(tokenId, operations) {
    const ops = [operations].flat();
    return {
        tokenId: tokenId,
        operations: Cbor.encode(ops),
    };
}
function parseTransfer(details) {
    if (typeof details !== 'object' || details === null)
        throw new Error(`Invalid transfer details: ${JSON.stringify(details)}. Expected an object.`);
    if (!('amount' in details) || !TokenAmount.instanceOf(details.amount))
        throw new Error(`Invalid transfer details: ${JSON.stringify(details)}. Expected 'amount' to be a TokenAmount`);
    if (!('recipient' in details) || !CborAccountAddress.instanceOf(details.recipient))
        throw new Error(`Invalid transfer details: ${JSON.stringify(details)}. Expected 'recipient' to be a TokenHolder`);
    if ('memo' in details && !(details.memo instanceof Uint8Array || CborMemo.instanceOf(details.memo)))
        throw new Error(`Invalid transfer details: ${JSON.stringify(details)}. Expected 'memo' to be Uint8Array | CborMemo`);
    return details;
}
function parseSupplyUpdate(details) {
    if (typeof details !== 'object' || details === null) {
        throw new Error(`Invalid supply update details: ${JSON.stringify(details)}. Expected an object.`);
    }
    if (!('amount' in details) || !TokenAmount.instanceOf(details.amount))
        throw new Error(`Invalid supply update details: ${JSON.stringify(details)}. Expected 'amount' to be a TokenAmount`);
    return details;
}
function parseListUpdate(details) {
    if (typeof details !== 'object' || details === null)
        throw new Error(`Invalid list update details: ${JSON.stringify(details)}. Expected an object.`);
    if (!('target' in details) || !CborAccountAddress.instanceOf(details.target))
        throw new Error(`Invalid list update details: ${JSON.stringify(details)}. Expected 'target' to be a TokenHolder`);
    return details;
}
function parseEmpty(details) {
    if (typeof details !== 'object' || details === null || Object.keys(details).length !== 0)
        throw new Error(`Invalid operation details: ${JSON.stringify(details)}. Expected empty object {}`);
    return details;
}
/**
 * Decode a single token operation from CBOR. Throws on invalid shapes, only returns Unknown variant when the key is unrecognized.
 */
function parseTokenOperation(decoded) {
    if (typeof decoded !== 'object' || decoded === null)
        throw new Error(`Invalid token operation: ${JSON.stringify(decoded)}. Expected an object.`);
    const keys = Object.keys(decoded);
    if (keys.length !== 1)
        throw new Error(`Invalid token operation: ${JSON.stringify(decoded)}. Expected an object with a single key identifying the operation type.`);
    const type = keys[0];
    const details = decoded[type];
    switch (type) {
        case TokenOperationType.Transfer:
            return { [type]: parseTransfer(details) };
        case TokenOperationType.Mint:
            return { [type]: parseSupplyUpdate(details) };
        case TokenOperationType.Burn:
            return { [type]: parseSupplyUpdate(details) };
        case TokenOperationType.AddAllowList:
            return { [type]: parseListUpdate(details) };
        case TokenOperationType.RemoveAllowList:
            return { [type]: parseListUpdate(details) };
        case TokenOperationType.AddDenyList:
            return { [type]: parseListUpdate(details) };
        case TokenOperationType.RemoveDenyList:
            return { [type]: parseListUpdate(details) };
        case TokenOperationType.Pause:
            return { [type]: parseEmpty(details) };
        case TokenOperationType.Unpause:
            return { [type]: parseEmpty(details) };
        default:
            return decoded;
    }
}
/**
 * Decodes a token operation.
 *
 * @param cbor - The CBOR encoding to decode.
 * @returns The decoded token operation.
 *
 * @example
 * const op = decodeTokenOperation(cbor);
 * switch (true) {
 *   case TokenOperationType.Transfer in op: {
 *     const details = op[TokenOperationType.Transfer]; // type is known at this point.
 *     console.log(details);
 *   }
 *   ...
 *   default: console.warn('Unknown operation', op);
 * }
 */
export function decodeTokenOperation(cbor) {
    const decoded = Cbor.decode(cbor);
    return parseTokenOperation(decoded);
}
/**
 * Decodes a list of token operations.
 *
 * @param cbor - The CBOR encoding to decode.
 * @returns The decoded token operations.
 *
 * @example
 * const ops = decodeTokenOperations(cbor);
 * ops.forEach(op => {
 *   switch (true) {
 *     case TokenOperationType.Transfer in op: {
 *       const details = op[TokenOperationType.Transfer]; // type is known at this point.
 *       console.log(details);
 *     }
 *     ...
 *     default: console.warn('Unknown operation', op);
 *   }
 * });
 */
export function decodeTokenOperations(cbor) {
    const decoded = Cbor.decode(cbor);
    if (!Array.isArray(decoded))
        throw new Error(`Invalid token update operations: ${JSON.stringify(decoded)}. Expected a list of operations.`);
    return decoded.map(parseTokenOperation);
}
/**
 * Parses a token update payload, decoding the operations from CBOR format.
 *
 * @param payload - The token update payload to parse.
 * @returns The parsed token update payload with decoded operations.
 *
 * @example
 * const parsedPayload = parseTokenUpdatePayload(encodedPayload);
 * parsedPayload.operations.forEach(op => {
 *   switch (true) {
 *     case TokenOperationType.Transfer in op: {
 *       const details = op[TokenOperationType.Transfer]; // type is known at this point.
 *       console.log(details);
 *     }
 *     ...
 *     default: console.warn('Unknown operation', op);
 *   }
 * });
 */
export function parseTokenUpdatePayload(payload) {
    const operations = decodeTokenOperations(payload.operations);
    return { ...payload, operations };
}
//# sourceMappingURL=TokenOperation.js.map