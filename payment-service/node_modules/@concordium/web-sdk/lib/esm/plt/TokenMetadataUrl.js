var _TokenMetadataUrl_nominal;
import { Buffer } from 'buffer/index.js';
import { registerEncoder } from 'cbor2/encoder';
import { cborDecode, cborEncode } from '../types/cbor.js';
import { Cbor } from './index.js';
/**
 * Protocol level token (PLT) metadata URL.
 */
class TokenMetadataUrl {
    /**
     * Constructs a new TokenMetadataUrl instance.
     */
    constructor(
    /** The inner url */
    url, 
    /** The checksum SHA-256 of the URL */
    checksumSha256, 
    /**
     * Additional metadata url fields. Any keys in this object must not collide with the explicit fields for the
     * type.
     */
    additional) {
        this.url = url;
        this.checksumSha256 = checksumSha256;
        this.additional = additional;
        _TokenMetadataUrl_nominal.set(this, true);
    }
    /**
     * Get a string representation of the token metadata URL.
     * @returns {string} The string representation.
     */
    toString() {
        return this.url;
    }
    /**
     * Get a JSON-serializable representation of the token metadata URL. This is called implicitly when serialized with JSON.stringify.
     * @returns {JSON} The JSON representation.
     */
    toJSON() {
        let url = { url: this.url };
        if (this.checksumSha256 !== undefined) {
            url.checksumSha256 = Buffer.from(this.checksumSha256).toString('hex');
        }
        if (this.additional !== undefined) {
            const pairs = Object.entries(this.additional).map(([key, value]) => [key, Cbor.encode(value).toJSON()]);
            url._additional = Object.fromEntries(pairs);
        }
        return url;
    }
}
_TokenMetadataUrl_nominal = new WeakMap();
/**
 * Create a protocol level token metadata URL.
 *
 * @param {string} url - The URL of the token metadata.
 * @param {Uint8Array} [checksumSha256] - The SHA-256 checksum of the URL.
 * @param {Record<string, unknown>} [additional] - Additional metadata fields.
 * @returns {TokenMetadataUrl} A new token metadata URL instance.
 */
export function create(url, checksumSha256, additional) {
    return new TokenMetadataUrl(url, checksumSha256, additional);
}
/**
 * Create a protocol level token metadata URL from a string value. If the url should be
 * accompanied by a checksum or any other additional values, use {@linkcode create} instead.
 *
 * @param {string} url - The string to create the token ID from.
 * @returns {TokenMetadataUrl} A new token metadata URL instance.
 */
export function fromString(url) {
    return new TokenMetadataUrl(url);
}
/**
 * Type predicate for {@linkcode Type}
 *
 * @param value value to check.
 * @returns whether `value` is of type {@linkcode Type}
 */
export function instanceOf(value) {
    return value instanceof TokenMetadataUrl;
}
/**
 * Converts {@linkcode JSON} to a token amount.
 *
 * @param {string} json The JSON representation of token metadata URL.
 * @returns {TokenMetadataUrl} The token metadata URL.
 */
export function fromJSON({ url, checksumSha256, _additional }) {
    let additional;
    if (_additional !== undefined) {
        const pairs = Object.entries(_additional).map(([key, value]) => [key, Cbor.decode(Cbor.fromJSON(value))]);
        additional = Object.fromEntries(pairs);
    }
    const checksumSha256Parsed = checksumSha256 !== undefined ? Uint8Array.from(Buffer.from(checksumSha256, 'hex')) : undefined;
    return create(url, checksumSha256Parsed, additional);
}
/**
 * Converts a TokenMetadataUrl object to it's intermediary {@linkcode CBOR} representation.
 *
 * @param tokenMetadataUrl - The TokenMetadataUrl object to convert.
 * @returns A CBOR-compatible value representation of the TokenMetadataUrl.
 */
export function toCBORValue(tokenMetadataUrl) {
    let cbor = { url: tokenMetadataUrl.url };
    if (tokenMetadataUrl.checksumSha256 !== undefined) {
        cbor.checksumSha256 = tokenMetadataUrl.checksumSha256;
    }
    if (tokenMetadataUrl.additional) {
        cbor = { ...cbor, ...tokenMetadataUrl.additional };
    }
    return cbor;
}
/**
 * Encodes a TokenMetadataUrl object into a CBOR-formatted Uint8Array.
 *
 * @param tokenMetadataUrl - The TokenMetadataUrl object to encode.
 * @returns A Uint8Array containing the CBOR encoding of the TokenMetadataUrl.
 */
export function toCBOR(tokenMetadataUrl) {
    return cborEncode(toCBORValue(tokenMetadataUrl));
}
/**
 * Constructs a TokenMetadataUrl object from it's {@linkcode CBOR}.
 *
 * @param value - The CBOR-compatible value to decode. The expected format is {@linkcode CBOR}.
 * @returns The decoded TokenMetadataUrl object.
 * @throws Will throw an error if the value is not a valid CBOR representation of TokenMetadataUrl.
 */
export function fromCBORValue(value) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Invalid CBOR value for TokenMetadataUrl');
    }
    if (!('url' in value) || typeof value.url !== 'string') {
        throw new Error('Missing or invalid "url" field in TokenMetadataUrl');
    }
    // check that checksumSha256 is either undefined or a Uint8Array of length 32
    if ('checksumSha256' in value &&
        (!(value.checksumSha256 instanceof Uint8Array) || value.checksumSha256.length !== 32)) {
        throw new Error('Invalid "checksumSha256" field in TokenMetadataUrl');
    }
    const { url, checksumSha256, ...other } = value;
    let additional;
    if (Object.keys(other).some((key) => typeof key !== 'string')) {
        throw new Error('Invalid additional fields in TokenMetadataUrl. Can only contain string keys.');
    }
    if (Object.keys(other).length > 0) {
        additional = other;
    }
    return create(url, checksumSha256, additional);
}
/**
 * Decodes a CBOR-encoded Uint8Array into a TokenMetadataUrl object.
 *
 * @param cbor - The CBOR-encoded Uint8Array to decode.
 * @returns The decoded TokenMetadataUrl object.
 * @throws Will throw an error if the CBOR data is not a valid representation of TokenMetadataUrl.
 */
export function fromCBOR(cbor) {
    return fromCBORValue(cborDecode(cbor));
}
/**
 * Registers a CBOR encoder for the TokenMetadataUrl type with the `cbor2` library.
 * This allows TokenMetadataUrl instances to be automatically encoded when used with
 * the `cbor2` library's encode function.
 *
 * @returns {void}
 * @example
 * // Register the encoder
 * registerCBOREncoder();
 * // Now TokenMetadataUrl instances can be encoded directly
 * const encoded = encode(myTokenMetadataUrl);
 */
export function registerCBOREncoder() {
    registerEncoder(TokenMetadataUrl, (value) => [NaN, toCBORValue(value)]);
}
//# sourceMappingURL=TokenMetadataUrl.js.map