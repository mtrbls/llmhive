import { Tag } from 'cbor2';
import { ContractAddress } from '../types/index.js';
/**
 * Enum representing the types of errors that can occur when creating a contract address.
 */
export declare enum ErrorType {
    /** Error type indicating a contract index exceeds the maximum allowed value. */
    EXCEEDS_MAX_VALUE = "EXCEEDS_MAX_VALUE",
    /** Error type indicating a contract index is negative. */
    NEGATIVE = "NEGATIVE"
}
/**
 * Custom error to represent issues with contract addresses.
 */
export declare class Err extends Error {
    /** The {@linkcode ErrorType} of the error. Can be used to distinguish different types of errors. */
    readonly type: ErrorType;
    private constructor();
    /**
     * Creates a CborContractAddress.Err indicating that the contract address index exceeds the maximum allowed value.
     */
    static exceedsMaxValue(): Err;
    /**
     * Creates a CborContractAddress.Err indicating that the contract address index is negative.
     */
    static negative(): Err;
}
/**
 * CIS-7 CBOR representation of a `ContractAddress`.
 */
declare class CborContractAddress {
    #private;
    /** The index of the smart contract address. */
    readonly index: bigint;
    /** The subindex of the smart contract address. Interpreted as `0` if not specified. */
    readonly subindex?: bigint | undefined;
    constructor(
    /** The index of the smart contract address. */
    index: bigint, 
    /** The subindex of the smart contract address. Interpreted as `0` if not specified. */
    subindex?: bigint | undefined);
    /**
     * Get a string representation of the contract address using the `<index, subindex>` format.
     * @returns {string} The string representation.
     */
    toString(): string;
    /**
     * Get the JSON representation (i.e. object format) of the contract address.
     * It's up to the user to process this, as bigints are not JSON serializable.
     * @returns {JSON} The JSON representation.
     */
    toJSON(): JSON;
}
/**
 * CIS-7 CBOR representation of a `ContractAddress`.
 */
export type Type = CborContractAddress;
/**
 * Type predicate for {@linkcode Type}.
 *
 * @param v - a value of unknown type to check
 * @returns whether the type is an instance of {@linkcode Type}
 */
export declare const instanceOf: (v: unknown) => v is CborContractAddress;
/**
 * The JSON representation of a {@linkcode Type} cbor contract address.
 * It's up to the user to process this, as bigints are not JSON serializable.
 */
export type JSON = {
    index: bigint;
    subindex?: bigint;
};
type NumLike = string | number | bigint;
/**
 * Create a CBOR-compatible contract address from numeric index (and optional subindex).
 *
 * @param index Index of the contract (string | number | bigint accepted, coerced via BigInt()).
 * @param subindex Optional subindex of the contract (same coercion rules). If `0`, the value is omitted.
 *
 * @returns CborContractAddress instance representing the provided (index, subindex).
 * @throws {Err} If index or subindex is negative ({@link Err.negative}).
 * @throws {Err} if index of subindex exceed MAX_U64 ({@link Err.exceedsMaxValue}).
 */
export declare function create(index: NumLike, subindex?: NumLike): CborContractAddress;
/**
 * Convert a public `ContractAddress.Type` (sdk representation) into its CBOR wrapper form.
 *
 * @param address The contract address value (with bigint index/subindex) to wrap.
 * @returns Equivalent CborContractAddress instance.
 */
export declare function fromContractAddress(address: ContractAddress.Type): CborContractAddress;
/**
 * Convert a CBOR wrapper contract address to the public `ContractAddress.Type`.
 *
 * @param address The CBOR contract address wrapper to convert.
 * @returns New `ContractAddress.Type` constructed from wrapper values.
 */
export declare function toContractAddress(address: CborContractAddress): ContractAddress.Type;
/**
 * Create a CborContractAddress from its JSON-like object representation.
 *
 * @param address Object with index and optional subindex.
 * @returns Corresponding CborContractAddress instance.
 */
export declare function fromJSON(address: JSON): CborContractAddress;
/**
 * Produce the tagged CBOR value representation (tag + contents) for a contract address.
 * Tag format simple: 40919(index).
 * Tag format full: 40919([index, subindex]).
 *
 * @param address The CBOR contract address wrapper instance.
 * @returns cbor2.Tag carrying the encoded address.
 */
export declare function toCBORValue(address: CborContractAddress): Tag;
/**
 * Encode a contract address to raw CBOR binary (Uint8Array) using its tagged representation.
 *
 * @param address The CBOR contract address wrapper to encode.
 * @returns Uint8Array containing the canonical CBOR encoding.
 */
export declare function toCBOR(address: CborContractAddress): Uint8Array;
/**
 * Registers a CBOR encoder for the CborContractAddress type with the `cbor2` library.
 * This allows CborContractAddress instances to be automatically encoded when used with
 * the `cbor2` library's encode function.
 *
 * @returns {void}
 * @example
 * // Register the encoder
 * registerCBOREncoder();
 * // Now CborContractAddress instances can be encoded directly
 * const encoded = encode(myCborContractAddress);
 */
export declare function registerCBOREncoder(): void;
/**
 * Decodes a CBOR-encoded contract address into an CborContractAddress instance.
 * This function can handle both the full format (with subindex)
 * and a simplified format with just the index.
 *
 * 1. With subindex:
 * ```
 * [uint, uint]
 * ```
 *
 * 2. Without subindex:
 * ```
 * uint
 * ```
 *
 * @param {Uint8Array} bytes - The CBOR encoded representation of an contract address.
 * @throws {Error} - If the input is not a valid CBOR encoding of an contract address.
 * @returns {Type} The decoded CborContractAddress instance.
 */
export declare function fromCBOR(bytes: Uint8Array): Type;
/**
 * Registers a CBOR decoder for the tagged-contract address (40919) format with the `cbor2` library.
 * This enables automatic decoding of CBOR data containing Concordium contract addresses
 * when using the `cbor2` library's decode function.
 *
 * @returns {() => void} A cleanup function that, when called, will restore the previous
 * decoder (if any) that was registered for the tagged-address format. This is useful
 * when used in an existing `cbor2` use-case.
 *
 * @example
 * // Register the decoder
 * const cleanup = registerCBORDecoder();
 * // Use the decoder
 * const tokenHolder = decode(cborBytes); // Returns CborContractAddress if format matches
 * // Later, unregister the decoder
 * cleanup();
 */
export declare function registerCBORDecoder(): () => void;
export {};
