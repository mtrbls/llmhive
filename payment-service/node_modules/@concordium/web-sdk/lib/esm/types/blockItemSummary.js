import { isKnown } from '../grpc/upward.js';
import { AccountTransactionType, TransactionSummaryType } from '../types.js';
import { isDefined } from '../util.js';
import * as AccountAddress from './AccountAddress.js';
import * as ContractAddress from './ContractAddress.js';
import { TransactionEventTag, } from './transactionEvent.js';
export var TransactionKindString;
(function (TransactionKindString) {
    TransactionKindString["DeployModule"] = "deployModule";
    TransactionKindString["InitContract"] = "initContract";
    TransactionKindString["Update"] = "update";
    TransactionKindString["Transfer"] = "transfer";
    TransactionKindString["AddBaker"] = "addBaker";
    TransactionKindString["RemoveBaker"] = "removeBaker";
    TransactionKindString["UpdateBakerStake"] = "updateBakerStake";
    TransactionKindString["UpdateBakerRestakeEarnings"] = "updateBakerRestakeEarnings";
    TransactionKindString["UpdateBakerKeys"] = "updateBakerKeys";
    TransactionKindString["UpdateCredentialKeys"] = "updateCredentialKeys";
    TransactionKindString["BakingReward"] = "bakingReward";
    TransactionKindString["BlockReward"] = "blockReward";
    TransactionKindString["FinalizationReward"] = "finalizationReward";
    TransactionKindString["EncryptedAmountTransfer"] = "encryptedAmountTransfer";
    TransactionKindString["TransferToEncrypted"] = "transferToEncrypted";
    TransactionKindString["TransferToPublic"] = "transferToPublic";
    TransactionKindString["TransferWithSchedule"] = "transferWithSchedule";
    TransactionKindString["UpdateCredentials"] = "updateCredentials";
    TransactionKindString["RegisterData"] = "registerData";
    TransactionKindString["TransferWithMemo"] = "transferWithMemo";
    TransactionKindString["EncryptedAmountTransferWithMemo"] = "encryptedAmountTransferWithMemo";
    TransactionKindString["TransferWithScheduleAndMemo"] = "transferWithScheduleAndMemo";
    TransactionKindString["ConfigureBaker"] = "configureBaker";
    TransactionKindString["ConfigureDelegation"] = "configureDelegation";
    TransactionKindString["StakingReward"] = "paydayAccountReward";
    TransactionKindString["Failed"] = "failed";
    TransactionKindString["TokenUpdate"] = "tokenUpdate";
})(TransactionKindString || (TransactionKindString = {}));
/**
 * Given an AccountTransactionType number value, return the corresponding TransactionKindString value
 */
export function getTransactionKindString(type) {
    return TransactionKindString[AccountTransactionType[type]];
}
/**
 * Type predicate for {@link InitContractSummary}.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether summary is of type `InitContractSummary`.
 */
export const isInitContractSummary = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    summary.transactionType === TransactionKindString.InitContract;
/**
 * Type predicate for {@link UpdateContractSummary}.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether summary is of type `UpdateContractSummary`.
 */
export const isUpdateContractSummary = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    summary.transactionType === TransactionKindString.Update;
/**
 * Type predicate for transfer-like transactions.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether summary is of type `TransferSummary` or `TransferWithMemoSummary`.
 */
export const isTransferLikeSummary = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    (summary.transactionType === TransactionKindString.Transfer ||
        summary.transactionType === TransactionKindString.TransferWithMemo);
/**
 * Type predicate for {@link FailedTransactionSummary}.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether transaction was rejected.
 */
export const isRejectTransaction = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    summary.transactionType === TransactionKindString.Failed;
/**
 * Helper function to determine whether a transaction was successful (inverse of {@link isRejectTransaction}).
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether transaction was successful.
 */
export const isSuccessTransaction = (summary) => !isRejectTransaction(summary);
export function getTransactionRejectReason(summary) {
    if (!isRejectTransaction(summary)) {
        return undefined;
    }
    return summary.rejectReason;
}
export function getReceiverAccount(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction) {
        return undefined;
    }
    switch (summary.transactionType) {
        case TransactionKindString.Transfer:
        case TransactionKindString.TransferWithMemo:
        case TransactionKindString.TransferWithScheduleAndMemo:
            return summary.transfer.to;
        case TransactionKindString.TransferWithSchedule:
            return summary.event.to;
    }
}
/**
 *
 * Takes a list of items and appends another list of items to it, given they are not already in the list
 * according to the eq function.
 *
 * @template T - the type of items in the list
 * @param list - the list to append to
 * @param items - the list to append to the existing list
 * @param eq - the equality function to use for checking uniqueness
 * @returns A new list consisting of unique items from both lists supplied
 *
 * NOTE: This is O(n*m) i.e. not great, but the expected data set is very small. If that ever changes,
 * consider optimizing.
 */
function addUnique(list, items, eq) {
    const next = [...list];
    const flattened = Array.isArray(items) ? items : [items];
    for (let i = 0; i < flattened.length; i++) {
        const item = flattened[i];
        if (!next.filter(isKnown).some((li) => eq(item, li))) {
            next.push(item);
        }
    }
    return next;
}
export function affectedContracts(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction) {
        return [];
    }
    switch (summary.transactionType) {
        case TransactionKindString.InitContract: {
            return [summary.contractInitialized.address];
        }
        case TransactionKindString.Update: {
            return summary.events.reduce((addresses, event) => {
                if (!isKnown(event)) {
                    return [...addresses, null];
                }
                if (event.tag !== TransactionEventTag.Updated) {
                    return addresses;
                }
                return addUnique(addresses, event.address, ContractAddress.equals);
            }, []);
        }
        default: {
            return [];
        }
    }
}
function tokenEventsAffectedAccounts(events, sender) {
    return events.reduce((addresses, event) => {
        if (!isKnown(event)) {
            return [...addresses, null];
        }
        switch (event.tag) {
            case TransactionEventTag.TokenTransfer:
                return addUnique(addresses, [event.to?.address, event.from?.address].filter(isDefined), AccountAddress.equals);
            case TransactionEventTag.TokenBurn:
            case TransactionEventTag.TokenMint:
                return addUnique(addresses, [event.target?.address].filter(isDefined), AccountAddress.equals);
            case TransactionEventTag.TokenModuleEvent:
                // This only includes the encoded events pertaining to list updates and token pausation,
                // thus not affecting any account's balance
                return addresses;
        }
    }, sender !== undefined ? [sender] : []);
}
function accTransactionsAffectedAccounts(summary) {
    switch (summary.transactionType) {
        case TransactionKindString.EncryptedAmountTransfer:
        case TransactionKindString.EncryptedAmountTransferWithMemo:
            return [summary.added.account, summary.removed.account];
        case TransactionKindString.TransferToEncrypted:
            return [summary.added.account];
        case TransactionKindString.TransferToPublic:
            return [summary.removed.account];
        case TransactionKindString.Update: {
            return summary.events.reduce((addresses, event) => {
                if (!isKnown(event)) {
                    return [...addresses, null];
                }
                if (event.tag !== TransactionEventTag.Transferred) {
                    return addresses;
                }
                return addUnique(addresses, event.to, AccountAddress.equals);
            }, [summary.sender]);
        }
        case TransactionKindString.TokenUpdate: {
            return tokenEventsAffectedAccounts(summary.events, summary.sender);
        }
        default: {
            const receiver = getReceiverAccount(summary);
            if (receiver === undefined || AccountAddress.equals(summary.sender, receiver)) {
                return [summary.sender];
            }
            return [summary.sender, receiver];
        }
    }
}
export function affectedAccounts(summary) {
    switch (summary.type) {
        case TransactionSummaryType.AccountTransaction:
            return accTransactionsAffectedAccounts(summary);
        case TransactionSummaryType.TokenCreation:
            return tokenEventsAffectedAccounts(summary.events);
        default:
            return [];
    }
}
export function getSummaryContractUpdateLogs(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction || !isUpdateContractSummary(summary)) {
        return [];
    }
    return summary.events
        .map((event) => {
        if (!isKnown(event)) {
            return null;
        }
        switch (event.tag) {
            case TransactionEventTag.Updated:
            case TransactionEventTag.Interrupted:
                return { address: event.address, events: event.events };
            default:
                return undefined;
        }
    })
        .filter(isDefined);
}
//# sourceMappingURL=blockItemSummary.js.map